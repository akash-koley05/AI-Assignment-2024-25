class Puzzle:
    def __init__(self, start_state, goal_state):
        self.start_state = start_state
        self.goal_state = goal_state
        self.visited = set()
        self.stack = [(start_state, [])]  # (current_state, path_to_state)

    def get_possible_moves(self, state):
        moves = []
        zero_pos = state.index(0)
        row, col = zero_pos // 3, zero_pos % 3
        
        # Movement directions (row, col) -> (up, down, left, right)
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            if 0 <= new_row < 3 and 0 <= new_col < 3:
                new_zero_pos = new_row * 3 + new_col
                new_state = list(state)
                new_state[zero_pos], new_state[new_zero_pos] = new_state[new_zero_pos], new_state[zero_pos]
                moves.append(new_state)
        
        return moves

    def dfs(self):
        while self.stack:
            current_state, path = self.stack.pop()
            if tuple(current_state) in self.visited:
                continue
            self.visited.add(tuple(current_state))
            
            # If goal state is reached
            if current_state == self.goal_state:
                return path + [current_state]
            
            # Explore possible moves
            for move in self.get_possible_moves(current_state):
                self.stack.append((move, path + [current_state]))
        
        return None  # If no solution is found

# Initial and goal state
start_state = [1, 2, 3, 4, 0, 5, 6, 7, 8]  # The 0 represents the blank tile
goal_state = [1, 2, 3, 4, 5, 6, 7, 8, 0]

# Create Puzzle object and solve using DFS
puzzle = Puzzle(start_state, goal_state)
solution = puzzle.dfs()

if solution:
    print("Solution found!")
    for step in solution:
        for i in range(3):
            print(step[i * 3: (i + 1) * 3])
        print()
else:
    print("No solution found.")
